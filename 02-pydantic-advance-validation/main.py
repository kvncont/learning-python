""" Pydantic advance validation """

import uuid
from typing import ClassVar, Self

from pydantic import (
    UUID4,
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    SecretStr,
    ValidationInfo,
    computed_field,
    field_validator,
    model_validator,
)
from pydantic.alias_generators import to_camel


class User(BaseModel):
    """User model"""

    user_schema: ClassVar = {
        "properties": {
            "id": {"description": "User ID generated by UUID4"},
            "name": {"description": "User name"},
            "lastName": {"description": "User last name"},
            "email": {"description": "User email"},
            "password1": {"description": "User password"},
            "password2": {"description": "User password"},
        },
        "example": {
            "id": uuid.uuid4(),
            "name": "Gabriel",
            "lastName": "Contreras",
            "email": "gabriel.contreras@emial.com",
            "password1": "123456",
            "password2": "123456",
        },
    }

    model_config = ConfigDict(
        alias_generator=to_camel,
        populate_by_name=True,
        extra="forbid",
        strict=True,
        json_schema_extra=user_schema,
    )

    id: UUID4 = Field(default_factory=uuid.uuid4)
    name: str = Field(min_length=2, max_length=50)
    last_name: str = Field(min_length=2, max_length=50)
    email: EmailStr = Field(frozen=True)
    password1: SecretStr = Field(min_length=6, max_length=10, exclude=True)
    password2: SecretStr = Field(min_length=6, max_length=10, exclude=True)

    @computed_field(alias="fullName")
    @property
    def full_name(self) -> str:
        """Full name computed field"""
        return f"{self.name} {self.last_name}"

    @field_validator("email")
    @classmethod
    def validate_email_domain(cls, value: str, info: ValidationInfo) -> EmailStr:
        """Validate email domain"""

        # info.field_name is the name of the field to validate
        # print(info.data["name"])  # Access to the data of the model
        if not value.endswith("@email.com"):
            raise ValueError(f"Invalid {info.field_name} domain")
        return value

    @model_validator(mode="before")
    @classmethod
    def check_fields(cls, data: any) -> any:
        """Check fields before validation"""
        if isinstance(data, dict):
            if "fieldInvalid" in data:
                raise ValueError(
                    "Invalid field: 'fieldInvalid' should not be in the include data"
                )
        return data

    @model_validator(mode="after")
    def check_passwords_match(self) -> Self:
        """Check if passwords match"""
        pw1 = self.password1
        pw2 = self.password2
        if pw1 is not None and pw2 is not None and pw1 != pw2:
            raise ValueError("passwords do not match")
        return self

    # Se puede hacer lo mismo con un field_validator pero no es la mejor práctica
    # @field_validator("password2")
    # @classmethod
    # def check_passwords_match(cls, value: str, info: ValidationInfo) -> Self:
    #     pw1 = info.data["password1"]
    #     pw2 = value
    #     if pw1 is not None and pw2 is not None and pw1 != pw2:
    #         raise ValueError('passwords do not match')
    #     return pw1


user = User(
    name="Gabriel",
    # lastName="Contreras",
    last_name="Contreras",
    email="gabriel.contreras@email.com",
    password1="123456",
    password2="123456",
)

print(user.model_dump_json(by_alias=True))
print(user.model_dump_json(by_alias=True, exclude_defaults=True, exclude_unset=True))

print()
print()

user2_data = {
    "name": "Darío",
    "lastName": "Contreras",
    # "email": "dario.contreras@gmail.com",
    "email": "dario.contreras@email.com",
    "password1": "123456",
    "password2": "123456",
    # "fieldInvalid": "invalid",
}

user2 = User(**user2_data)
print(user2.model_dump_json(by_alias=True, exclude_defaults=True, exclude_unset=True))
